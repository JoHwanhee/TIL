<pre>
컴퓨터는
CPU + RAM + 버스

CPU에는 ALU, CU, REGISTERS가 있음
ALU는 계산장치고
CU는 CPU의 동작을 관할함
레지스터는 CPU가 연산할때 뭐 주소를 저장하거나 데이터를 저장하거나 등등 임시 저장함

자 그럼 a.exe라는 프로그램을 실행시킨다고하면
OS가 IO버스로 하드디스크에 있는 a.exe를 RAM에 COPY시킴
그러면 CPU는 RAM에 있는 프로세스의 명령어들을 하나씩 FETCH함
FETCH한 정보는 CPU에 버스 인터페이스를 통해 레지스터에 DECODE함
레지스터에 저장된 정보를 ALU가 EXCUTION함
이 구조를 STORED PROGRAM CONCEPT라고 함 (폰노이만 구조라고도 함)

그리고 이런 하나의 동작 동작들을 클럭이라고 하고
이는 클럭발생기에 의해 클럭이 생성됨
클럭발생기는 각 장치별로 있고
장치별 최소 클럭이 컴퓨터 전체적인 성능이 됨

자 이제부터는 각 명령어들을 직접 설계해볼거임

명령어를 설계하려면 우선
레지스터정의가 필요함
r0
r1
r2
r3 을 범용
r4
r5
r6
r7 을 각 addr ir 등으로 쓰는데 아직 안 배움

그리고 명령어 함수를 정의함
ADD 001
LOAD 010
MIN 011 등등과 같이 함

그래서 명령어조합을 함
ex) ADD r1 r2 r3 -> r2 r2에 있는 정보를 더해서 r1에 저장하라
이렇게 하려면 r2 r3에 정보를 저장해야하니까
LOAD가 필요함
LOAD는 RAM으로부터 데이터를 REG에 불러오는것
반대로 
STORE는 REG -> RAM임


64비트 버스라면, 명령어가 64비트라는 말인데
그 말은 명령어 조합이 64비트 이내란 말이고
그 말은 각 조합이 64비트를 넘어선 안 된다는 말이 된다.

그렇다면 조합중 하나인 피연산자 or 주소 등이 64비트로 표현하는 경우면 어떻게 해야하나?

클럭생성은 누가 하는가?

LOAD명령어와 STORE의 필요성
-> 명령어가 제한되어있ㅇ니까

LOAD나 STORE 명령어는 주소값을 갖고 하는데,,,,
명령어는 64비트잖아?
근데 주소값도 64비트야
그럼 어떻게 해?

LOAD r1 0x10
LOAD r2 0x20
ADD r3 r1 r2
STORE r3 0x30

direct mode indirect mode

int a = 10; // 0x0010
int b = 20; //0x0100 
int c = 0; // 0x0020
c = a + b;

LOAD r1 0x0010

MUL r0 4 4
MUL r2 4 4
MUL r3 r0 r2 

STORE r3 0x0030
LOAD r2 0x0030

ADD r3 r1 r2

RAM보다 프로세스 크기가 커지면?
 - 우선은 가상 메모리 덕분에 된다고 생각하자.

프로세스가 뭐지??
 - 메모리구조 + 레지스터 Set
 - 프로세스별로 독립적으로 할당받는 모든 메모리들

프로세스 스케쥴러
 - CPU는 한 순간에 하나의 프로세스만 실행 가능하다.
 - 그런데 여러 프로세스를 사용하려면?
 - 프로세스들을 교체해줘야한다.
 - 근데 스케쥴러 자체도 프로세스다.
 - 그래서 스케쥴러가 동작되는 시간에도 CPU는 다른일을 못한다.
 - 따라서 가급적 스케쥴러 호출을 적게할 수록 좋다.

이 상태전이는 스케쥴러가 선택한다.
 Running state : CPU에 올라와 있는 상태 - 
 Ready state : Running 하고싶은 상태 - 
 Blocked state

I/O연산은 CPU가 하는게 아님!!
I/O를 하고 있으면 Blocked로 넘김

컨텍스트 스위칭
 - 프로세스가 running state로 넘어갈 때 프로세스 종속된 데이터들과 MainMemory에 있는 데이터를 교환하는ㄷ..

커널 오브젝트
 - 커널에 의해 관리되는 리소스 정보를 담고 있는 데이터 블록 ( 파이프, 프로세스, 쓰레드, 파일 등)
 - 프로세스를 관리하려면, 프로세스 관련된 프로세스 커널 오브젝트가 생성됨
 - 파일을 생성하면 그 파일에 해당하는 파일 커널 오브젝트가 생성됨
 - 쓰레드도 뭐도 다 마찬가지임

커널 오브젝트의 특정 요소를 바꾸기위해선?
 -> 커널 오브젝트에 직접 접근은 안 되고, 간접적으로 접근해야함
 -> 그래서 그거에 관련된 API를 제공해줌 ex) upc()
 -> 이때 인자로 커널 오브젝트를 넘겨줄 순 없음 (다 막아놨기때문에)
 -> 그래서 우리가 커널 오브젝트가 생성될 때 그에 관련된 핸들을 반환하는데 (근데 또 각 리소스별로다름)
 -> 그 핸들을 API에 전달하는 방식으로 함
 -> 한 프로세스가 생성이 되면 그 프로세스는 핸들테이블에 핸들을 생성하고 그 테이블은 핸들 값이랑 그 대상체의 주소가 담겨있음
 -> 그 핸들 테이블에는 자식 프로세스의 핸들도 있고 자기의 핸들도 있음 
 -> 자식 프로세스 만들때 자식의 핸들값을 부모가 가짐
 -> 즉 핸들테이블은 각 프로세스에 종속적임
 -> 자식 프로세스가 종료되어도 커널 오브젝트는 사라지지 않음! UC가 1이라서
 -> UC는 자기한테 참조되고 있느 ㄴ애들
 -> main에 있는 return 은 커널 오브젝트에 들어감!!!!!!!! (종료 상태를 저장함)
 -> 그래서 부모가 자식프로세스의 상태 확인할 때 자식의 핸들을 통해 자식의 커널 오브젝트를 접근해 해당 프로세스의 상태를 체크 
 -> 근데 사실은 자기 자신의 핸들 정보는 자기 핸들 테이블에 저장되지 않음
 -> 그럼 자기 핸들을 가져오려면?getCurrentProcess()가 있는데 이는 -1이 return 되는데 이건 진짜 핸들이 아니라 그냥 자기 자신을 나타내는 핸들의 상수임
 -> closehandle을 하면 부모가 자식을 포기하는 형태가됨, 그럼 얘들은 부-모 자식관계가 아니라 그냥 부모에 있는 핸들테이블에서 자식 핸들을 제거하는 것 -> 좀비 프로세스 생성을 방지할 수 이씀

프로세스간 통신!! IPC
 -> 서로 통신하는 방식은 특정 데이터 영역을 두고 그 영역을 공유하는 형태임
 -> 이때 사용하는 기법이 메일 슬롯
 -> 이는 단방향 특성임 Sender -> Receiver 로만 데이터 전송 가능
 -> Broadcasting 가능 함
 -> 결국 메일슬롯도 파일 하나
 -> ReadFile, WriteFile

- 프로세스 만들면 커널 오브젝트가 생성되고 그 오브젝트의 상태는 Non-signaled가 됨
- Non-signaled상태는 Running 상태라는걸 나타냄


</pre>