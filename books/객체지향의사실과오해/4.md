# 역할, 책임, 협력
우리 모두를 합친 것보다 더 현명한 사람은 없다.

## 협력
협력의 본질은 요청과 응답으로 연결되는 사람들의 네트워크다. 일반적으로 우리가 직면하게 되는 문제는 혼자만의 힘으로는 해결하기 어렵기 때문에 해결 과정에 여러 사람이 참여하게 된다. 이 과정 속에서 요청과 응답의 연쇄적인 흐름이 발생한다.
- 협력은 한 사람이 다른 사람에게 도움을 요청할 때 시작된다.
- 요청을 받은 사람은 일을 처리한 후 요청한 사람에게 필요한 지식이나 서비스를 제공하는 것으로 요청에 응답한다.
- 결과적으로 협력은 다수의 요청과 응답으로 구성되며 전체적으로 협력은 다수의 연쇄적인 요청과 응답의 흐름으로 구성된다.
    * 개인적으로 연쇄적인 요청과 응답이 많아질수록 애플리케이션의 복잡도가 증가한다고 생각함. 코드의 가독성이 오히려 떨어지는 경우를 자주 봄
	
## 재판속의 협력
- 누군가가 왕에게 재판을 요청
- 왕이 하얀 토끼에게 증인을 부를것을 요청
- 토끼는 모자장수에게 증인석으로 입장할것을 요청
- 모자장수는 증인석에 입장 함으로써 응답
- 왕은 모자장수에게 증언할 것을 요청
- 모자장수는 자신이 알고있는 내용을 증언함으로써 왕의 요청에 응답

``` java
class 누군가 {
	public void 재판요청로직() {
		왕 w = new 왕();
		재판결과 결과 = 왕.재판하라();
		
		if(결과 == "유죄") {
			// todo 
		}
		else if (결과 == "무죄") {
			// todo 
		}
	}
}

class 왕 {
	public 재판결과 재판하라(){
		토끼 하얀토끼 = new 토끼();
		증인 증인 = 하얀토끼.증인을호출하라();
		
		증언 증언 = 증인.증언하라();
		
		return 내부_재판(증언);
	}
	
	private 재판결과 내부_재판(증언 증언) {
		return 재판결과;
	}
}

class 토끼 {
	public 증인 증인을호출하라(){
		모자장수 증인 = new 모자장수();
		return 증인;
	}
}

class 모자장수 {
	public 증언 증언하라(){
		return 증언;
	}
}
```

## 책임
- 객체지향 개발에서 가장 중요한 능력은 책임을 능숙하게 소프트웨어 객체에 할당하는 것
- 객체가 하는 것
    - 객체를 생성하거나 계산을 하는 등의 스스로 하는 것
	- 다른 객체의 행동을 시작시키는 것
	- 다른 객체의 활동을 제어하고 조절 하는 것
- 객체가 아는 것
    - 개인적인 정보에 관해 아는 것
	- 관련된 객체에 관해 아는 것
	- 자신이 유도하거나 계산할 수 있는 것에 관해 아는 것
- 객체의 책임을 이야기할 때는 일반적으로 외부에서 접근 가능한 공용 서비스의 관점에서 이야기한다.
- 즉 아는것, 하는것만 보여준다.
- 따라서 책임은 객체의 공용 인터페이스를 구성한다.
- 설계를 시작하는 초반에는 어떤 객체가 어떤 책임을 가지고 어떤 방ㅅ핵으로 서로 협력해야 하는지에 대한 개요를 아는 것만으로도 충분하다.

## 역할
- 재판이라는 협력 과정 속에서 왕과 하트여왕은 `판사` 역할, 모자 장수와 요리사 그리고 엘리스는 `증인`역할을 수행한다.
- 따라서 다음과 같이 역할과 협력으로 추상화할 수 있다.
    - 누군가 `판사`에게 재판을 요청
	- `판사`는 하얀 토끼에게 증인을 부를것 요청
	- `판사`의 요청을 받은 토끼는 `증인`에게 증인석으로 입장할 것을 요청
	- `증인`은 증인석에 입장함으로써 응답
	- `증인`의 입장은 연쇄적으로 토끼에 대한 `판사`의 요청에대한 응답
	- 이제 `판사`는 `증인`에게 증언할 것을 요청
	- `증인`은 자신이 알고있는 내용을 증엏남으로써 `판사`의 요청에 응답
- 요약하면 역할의 개념을 사용하면 유사한 협력을 추상화해서 인지 과부하를 줄일 수 있다.
- 역할은 객체 지향 설계의 단순성, 유연성, 재사용성을 뒷받침하는 핵심 개념이다.

``` java
class 누군가 {
	public void 재판요청로직() {
		판사 w = new 왕();
		재판결과 결과 = 왕.재판하라();
		
		if(결과 == "유죄") {
			// todo 
		}
		else if (결과 == "무죄") {
			// todo 
		}
	}
}

class 왕 implements 판사 {
	public 재판결과 재판하라(){
		토끼 하얀토끼 = new 토끼();
		증인 증인 = 하얀토끼.증인을호출하라();
		
		증언 증언 = 증인.증언하라();
		
		return 내부_재판(증언);
	}
	
	private 재판결과 내부_재판(증언 증언) {
		return 재판결과;
	}
}

class 여왕 implements 판사 {
	public 재판결과 재판하라(){
		토끼 하얀토끼 = new 토끼();
		증인 증인 = 하얀토끼.증인을호출하라();
		
		증언 증언 = 증인.증언하라();
		
		return 내부_재판(증언);
	}
	
	private 재판결과 내부_재판(증언 증언) {
		return 재판결과;
	}
}

class 토끼 {
	public 증인 증인을호출하라(){
		증인 증인 = new 모자장수();
		return 증인;
	}
}

class 모자장수 implements 증인 {
	public 증언 증언하라(){
		return 증언;
	}
}

class 엘리스 implements 증인 {
	public 증언 증언하라(){
		return 증언;
	}
}

interface 증인 {
	증언 증언하라();
}

interface 판사 {
	재판결과 재판하라();
}
```

## 대체가능성
- 역할은 협력 안에서 구체적인 객체로 대체될 수 있는 추상적인 협력자다.
- 객체가 주어진 책임 이외에 다른 책임을 수행할 수도 있다는 사실에 주목하라.

## 흔한 오류
- 데이터 먼저 개발 노노!
- 협력에 따라 흐르는 객체의 책임에 맞춰서 개발하자.
- 객체에게 책임을 할당하고 나면 책임으 ㄴ객체가 와부에 제공하게 될 행동이 된다.